{% extends "layout.html" %}
{% block body %}
<div class="container">
	<h3>Sample: {{sample_name}}</h3>
	<h4>SV: {{event_id}}</h4>
	<br>
	<table class="table table-hover" id="breakend-list">
		<thead><tr>
		{% for attr in attrs_to_show %}
			<th>{{ attr }}</th>
		{% endfor %}
		</tr></thead>
		<tbody></tbody>
	</table>

  <h4>Structure View</h4>
  <div id="breakend-viz">
    
  </div>
  
  <div id="gene-list">
    <h4></h4>
    <table id="gene-list-table" class="table-no-bordered"  data-toggle="table" data-cache="false" data-height="225">
      <thead><tr>
        <th data-field="external_name">Name</th> 
        <th data-field="start">Start</th> 
        <th data-field="end">End</th> 
        <th data-field="biotype">Biotype</th> 
        <th data-field="description">Description</th> 
      </tr></thead>
      <tbody></tbody>
    </table>
  </div>

</div>

<script type="text/javascript">
var event_type = {{ event_type|tojson|safe }};
var breakends = {{ breakends|tojson|safe }};
var columns = {{ attrs_to_show|tojson|safe }};
var selected_breakend = breakends[0];
var gene_range = 1000000; // in bp
var arrangement = {{ arrangement|tojson|safe }};
var blocks = {{ blocks|tojson|safe }};

// SV Visualization

// SVG setup 

var svg_width = 1000;
var svg_height = 150;
var viz = d3.select("#breakend-viz").append("svg")
  .attr('height', svg_height);

// Create sequence blocks

var block_scale = 50;
var block_height = 50;
var block_padding = 0;
var block_default_w = 10000;
var block_color = ['rgba(0,0,0,0.8)', 'rgba(0,0,150,0.5)', 'rgba(0,0,0,0.8)'];
var block_group, rects, arrows, bp_labels, start_label, x0, a;

var arrow = function(xLength, yPad, direction) {
  // should use transform instead of adding pad
  if (direction) {
    var lineData = [
      { "x": 0,   "y": yPad},  { "x": xLength-20,  "y": yPad},
      { "x": xLength,  "y": 20+yPad}, { "x": xLength-20,  "y": 40+yPad},
      { "x": 0,  "y": 40+yPad},  { "x": 0, "y": yPad}];
  } else {
    var lineData = [
      { "x": xLength,   "y": yPad},  { "x": 20,  "y": yPad},
      { "x": 0,  "y": 20+yPad}, { "x": 20,  "y": 40+yPad},
      { "x": xLength,  "y": 40+yPad},  { "x": xLength, "y": yPad}];
  }

  var lineFunction = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");

  return lineFunction(lineData);
};


// Load JSON data on blocks
var json_blocks_url = '/sample:{{sample_name}}/event:{{event_id}}/sv_blocks.json';
d3.json(json_blocks_url, function(error, data) {
  if (error) throw error;

  x0 = 0;
  data.forEach(function(d) {
    var w = Math.abs(d.end.pos - d.start.pos);
    var x1 = x0 + w;
    d.x0 = x0;
    d.w = w;
    d.x1 = x1;
    x0 = x1;
    d.expanded = false;
  });

  viz.attr('width', (block_default_w/block_scale + block_padding)*data.length);
  var xScale = d3.scale.linear()
    .domain([0, x0])
    .range([0, svg_width]);

  var y = 50;
  block_group = viz.selectAll('g')
      .data(data)
      .enter()
      .append('g');

  block_group
      .attr('id', function(d) {
        d.id = 'chr' + d.start.chrom + '' + d.start.pos;
        return d.id;
      })
      .attr('transform', function(d, i) {
        d.x_offset = i*(block_default_w/block_scale + block_padding);
        return 'translate(' + d.x_offset + ', ' + 0 + ')';
      })
      .classed('lined', function(d, i) {
        return (i != 0); // :^C
      });
  
  arrows = block_group.append('path')
      .classed('sequence_block',true)
      .attr('d', function (d) {
        d.xLength = block_default_w/block_scale;
        return arrow(d.xLength, 60, d.dir);
      })
      .attr('fill', function(d, i) {
        return block_color[i];
      })
      .on('click', function(d, i) {
        d.expanded = !d.expanded;
        expandBlock(d, i);
      });

  bp_labels = viz.selectAll('g.lined')
    .append('g')
    .data(function(d, i){
      return arrangement; // doesn't work as just data(arrangement)...
    });

  bp_labels
    .on('mouseover', function() {
      d3.select(this).classed("select-label", true);
      d3.select(this).select('text.start-label').attr('x', function() {
        return -(this.textLength.baseVal.valueInSpecifiedUnits + label_padding);
      });

      // need to include unique IDs for breakends in dataset for this object instead
      this.__data__.forEach(function(d) {
        var selected_end = 'chr' + d[0] + '-' + d[1];
        d3.select('.' + selected_end).classed('bolded', true);
      });

    })
    .on('mouseout', function() {
      d3.select(this).classed("select-label", false);
      d3.select(this).select('text.start-label').attr('x', function() {
        return -(this.textLength.baseVal.valueInSpecifiedUnits + label_padding);
      });

      this.__data__.forEach(function(d) {
        var selected_end = 'chr' + d[0] + '-' + d[1];
        d3.select('.' + selected_end).classed('bolded', false);
      });
    });

  bp_labels
    .append('line')
      .attr('x1', 0)
      .attr('x2', 0)
      .attr('y1', 0)
      .attr('y2', 100)
      .attr('stroke', 'black')
      .attr('stroke-width', 2);

  var label_padding = 5;
  var label_height = 20;
  start_label = bp_labels
    .append('text')
    .text(function(d, i) {
      return d[0][0] + ': ' + d[0][1];
    });

  start_label
    .attr('class', function(d) {
      return 'chr' + d[0][0] + '-' + d[0][1];
    })
    .classed('start-label', true)
    .attr('x', function() {
      return -(this.textLength.baseVal.valueInSpecifiedUnits + label_padding);
    })
    .attr('y', label_height);

  var end_label = bp_labels
    .append('text')
    .text(function(d) {
      return d[1][0] + ': ' + d[1][1];
    })
    .attr('class', function(d) {
      return 'chr' + d[1][0] + '-' + d[1][1];
    })
    .attr('x', label_padding)
    .attr('y', label_height);

  // Show scroll bar?
  var expandBlock = function(s_d, s_i) {
      var selected_group = d3.select('#' + s_d.id);
      var selected_arrow = selected_group.select('path');

      var old_width = s_d.xLength;
      var new_width = d3.round(((s_d.expanded) ? s_d.w : block_default_w)/block_scale);
      var width_change = new_width - old_width;

      data[s_i].xLength = new_width;
      selected_arrow.attr('d', arrow(new_width, 60, s_d.dir));

      for (i = s_i + 1; i < data.length; i++) { 
        var next = d3.select('#' + data[i].id); 
        data[i].x_offset = data[i].x_offset + width_change;
        next.attr('transform',  'translate(' + data[i].x_offset + ', ' + 0 + ')');
      }
  };
});


// Create breakend table

var rows = d3.select("#breakend-list tbody").selectAll('tr')
  .data(breakends)
  .enter()
  .append('tr')
  .attr('class', function(d) {
    return 'chr' + d['CHROM'] + '-' + d['POS'];
  })
  .on("click", function(d, i) {
    selected_breakend = d;
    get_genes();
    $('#breakend-list').find('tr.highlight').removeClass('highlight');
    $(this).addClass('highlight');
  });
d3.select("#breakend-list tbody").select('tr').classed('highlight', true);

var cells = rows.selectAll("td")
  .data(function(row) {
    return columns.map(function(column) {
      var cell = row[column];
      if (typeof cell == 'object') {
        return Object.keys(cell);
      }
      return cell;
    })
  })
  .enter()
  .append("td")
  .text(function(d) {
    return d;
  });

// Create list of genes around a selected breakend

/* TODO
1. use strict ranges (use block regions as cutoffs)
2. show indicators of function (cancer-related particularly)
*/

var gene_list = d3.select("#gene-list");
var gene_list_title = gene_list.select("h4");
var gene_list_headings = gene_list.select('thead tr');


var last_url, j;
var get_genes = function() {
  var chrom_id = selected_breakend['CHROM'];
  var position = selected_breakend['POS'];
  var start = position - gene_range;
  var end = position + gene_range;
  var url = '/genes/' + chrom_id + ':' + start + '-' + end;

  var heading_msg = "Genes within " + gene_range + "bp of selected breakend " + selected_breakend['CHROM'] + ':' + selected_breakend['POS'];
  gene_list_title.text(heading_msg);
 
  if (url != last_url) {
    $.getJSON(url, function(json){
      if (json) {
        for(var i=0; i<json.length; i++) { // inefficient (need to figure out how bootstrap-table formatter works)
          json[i]['biotype'] = json[i]['biotype'].replace('_', ' ');
        }
        $('#gene-list-table').bootstrapTable('load', json);

        // D3-ify (data binding)
        var rows = gene_list.select('tbody').selectAll('tr');
        rows.data(json).enter();

        var cols = a.selectAll('td');
        cols.data(function(d) {
          return [d.external_name, d.start, d.end, d.biotype, d.description];
        }).enter();
        
        cols.attr('class', function(d, i) {
          var attr = ['external_name', 'start', 'end', 'biotype', 'description']; // redundant
          return attr[i];
        })

        // Add links to name column
        d3.selectAll('.external_name')
          .text('')
          .append('a')
          .attr('href', function(d, i) {
            return 'http://www.genecards.org/cgi-bin/carddisp.pl?gene=' + d3.select(this.parentNode.parentNode).datum().id;
          })
          .text(function (d) { return d; });

      }
    });
    last_url = url;
  }
  /*
  if (url !== last_url) {

    /*
    
        response = json;
        //gene_list.select('tbody').selectAll('tr').remove(); // Clean out old listings 

        var heading_msg;
        if (response && response.length) {
          
        /*
          gene_list_headings.selectAll('th')
            .data(['Name', 'Start', 'End', 'Biotype', 'Description'])
            .enter()
            .append('th')
            .text(function(d) {
              return d;
            })
            .classed('col-xs-2', true);

          
          var gene_row = gene_list.select('tbody')
            .selectAll("tr")
            .data(response)
            .enter()
            .append("tr");

          gene_row
            .append('td')
            .append("a")
            .text(function(d) {
              return d['external_name'];
            })
            .attr("href", function(d) {
              // Need more flexible link
              return 'http://www.genecards.org/cgi-bin/carddisp.pl?gene=' + d['id'];
            });



          heading_msg = "Genes within " + gene_range + "bp of selected breakend " + selected_breakend['CHROM'] + ':' + selected_breakend['POS'];
        } else {
          heading_msg = "No genes were found within " + gene_range + "bp of this breakend.";
        }
        gene_list_title.text(heading_msg);
        last_url = url;
    });
  }*/
};
get_genes();
    
</script>
{% endblock %}