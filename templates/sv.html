{% extends "layout.html" %}
{% block body %}
<div class="container-fluid">

	<h3>Sample: {{sample_name}}</h3>
	<h4>SV: {{event_id}}</h4>
	<br>
	<table id="breakend-list" class="table table-hover" style='display: none;'>
		<thead><tr>
		{% for attr in attrs_to_show %}
			<th>{{ attr }}</th>
		{% endfor %}
		</tr></thead>
		<tbody></tbody>
	</table>

  <h4>Structure View</h4>
  <div id="breakend-viz"></div>


  <h4>Genes near break points</h4>
  <div id="gene-list" class="row"></div>

</div>

<script type="text/javascript">
var event_type = {{ event_type|tojson|safe }};
var breakends = {{ breakends|tojson|safe }};
var columns = {{ attrs_to_show|tojson|safe }};
var selected_breakend = breakends[0];
var arrangement = {{ arrangement|tojson|safe }};
var num_breakpoints = arrangement.length;
var blocks = {{ blocks|tojson|safe }};
var genes = {{ genes|tojson|safe }};

// Helper functions ******************************************************

var isEven = function(n) {
  return n == parseFloat(n)? !(n%2) : void 0;
};

// SV Visualization ******************************************************

// Create SVG viewport
var num_blocks = blocks.length;
var margin = {top: 20, right: 40, bottom: 20, left: 40};
var svg_width = $('#breakend-viz').innerWidth() - margin.left - margin.right,
    svg_height = 200 - margin.top - margin.bottom;
var axis_height = svg_height/2;
var tick_height = axis_height;
var toggleScaleView = false;

var svg = d3.select("#breakend-viz").append("svg")
    .style('border', 'solid black 2px')
    .attr("width", svg_width + margin.left + margin.right)
    .attr("height", svg_height + margin.top + margin.bottom);
var canvas = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// Create view for each block
var block_color = ['rgba(0,0,0,0.7)', 'rgba(102, 65, 164, 0.7)', 'rgba(0,0,0,0.7)'];
var block_widths = [];
var domains = [];
var xAxisGroups = [];
for (var i = 0; i < num_blocks; i++) {
  var block = blocks[i];
  block.domain = [block.start.pos, block.end.pos];
  block.domain_length = Math.abs(block.start.pos - block.end.pos);
  block.width = Math.round(svg_width/num_blocks);
  block.xScale = d3.scale.linear()
                   .domain(block.domain)
                   .range([1, block.width]);
  block.color = block_color[i];
  blocks[i] = block;
}

// Create scaled x axis for each block
var xAxisGroup = canvas.selectAll('g.axis')
    .data(blocks).enter()
    .append('g')
    .classed('axis', true)
    .attr('block-number', function (block, i) { return i; })
    .attr('transform', function (block, i) {
      return 'translate(' + (i * block.width) + ',' + axis_height + ')';
    });
xAxisGroup
    .each(function (block, i) {
      var xAxis = d3.svg.axis()
            .orient((isEven(i)) ? 'top' : 'bottom')
            .tickValues(block.domain)
            .tickSize(tick_height,0)
            .scale(block.xScale)
      d3.select(this).call(xAxis);
    });
  
// Draw block arrows over axes *******************************************

var block_height = Math.round(svg_height/3);
var block_y = -block_height/2;

// Helper method for drawing block shape - an arrow that can point left or right
var arrow = function(xLength, direction) {
  if (xLength > block_height/2) 
    if (direction) { 
      var lineData = [
        { "x": 0,   "y": 0},  { "x": xLength*0.9,  "y": 0},
        { "x": xLength,  "y": block_height/2}, { "x": xLength*0.9,  "y": block_height},
        { "x": 0,  "y": block_height},  { "x": 0, "y": 0}];
    } else {
      var lineData = [
        { "x": xLength,   "y": 0},  { "x": xLength*0.1,  "y": 0},
        { "x": 0,  "y": block_height/2}, { "x": xLength*0.1,  "y": block_height},
        { "x": xLength,  "y": block_height},  { "x": xLength, "y": 0}];
    }
  else { // draw directionless block
      var lineData = [
        { "x": 0,   "y": 0},  { "x": xLength,  "y": 0},
        { "x": xLength,  "y": block_height}, { "x": 0,  "y": block_height}];
  }

  var lineFunction = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");

  return lineFunction(lineData);
};

// Load JSON data on blocks
var json_blocks_url = '/sample:{{sample_name}}/event:{{event_id}}/sv_blocks.json';
d3.json(json_blocks_url, function(error, data) {
  if (error) throw error;

  xAxisGroup.each(function(block, i) {
    d3.select(this)
      .append("path")
      .classed('block', true)
      .attr('d', arrow(block.width, block.dir))
      .attr('transform', 'translate(0, ' + block_y + ')')
      .style('fill', block.color)
      .style('stroke', 'rgba(0,0,0,0.5)')
      .style('stroke-width', '2px')
      .style('stroke-linejoin', 'round')
      .style('shape-rendering', 'geometricPrecision');
  });
});

// Draw genes over axes **************************************************

var gene_height = svg_height/1.5;
var gene_y = -gene_height/2;
var gene_color = ['rgba(229, 0, 67, 0.3)', 'rgba(18, 135, 192, 0.3)', 'rgba(229, 0, 67, 0.3)'];
var gene_rects = [];

var gene_path = function(block) {
  var xScale = block.xScale;
  var start = xScale(block.start.pos), 
      end = xScale(block.end.pos);

  var lineData = [
    { "x": start,   "y": 0},  { "x": end,  "y": 0},
    { "x": end,  "y": gene_height}, { "x": start,  "y": gene_height}];
    
  var lineFunction = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");

  return lineFunction(lineData);
};

xAxisGroup.each(function (block, i) {
  if (genes[i]) {
    d3.select(this).selectAll('path.gene')
      .data(genes[i]).enter()
      .append('path')
      .classed('gene', true)
      .attr('d', gene_path(block))
      .attr('transform', 'translate(0, ' + gene_y + ')')
      .style('stroke', 'none')
      .style('fill', gene_color[i])
      .on('mouseover', function() {
        d3.select(this).classed('gene-selected', true);
      })
      .on('mouseout', function() {
        d3.select(this).classed('gene-selected', false);
      });
  }
});

// Update SVG size *******************************************************

// Rescale SVG when window is resized 
$(window).resize(function() {
    svg_width = $('#breakend-viz').innerWidth() - margin.left - margin.right;
    svg.attr("width", svg_width + margin.left + margin.right)
    updateBlocks();
});

// Toggle scaled and schematic views when SVG is clicked 
var sum = d3.sum(_.map(blocks, function (block) { return block.domain_length; }));
$('#breakend-viz svg').click(function() {
  toggleScaleView = !(toggleScaleView);
  updateBlocks();
});

// Helper method for updating block widths
var updateBlocks = function() {
  // Update block size
  if (toggleScaleView) {
    var windowScale = d3.scale.linear().domain([1, sum]).rangeRound([1, svg_width]);
    _.each(blocks, function(block) { block.width = windowScale(block.domain_length); });
  } else {
    var fixed_width = Math.round(svg_width/num_blocks);
    _.each(blocks, function(block) { block.width = fixed_width; });
  }
  
  // Resize SVG elements to fit new block size
  var sumPreviousWidths = 0;
  xAxisGroup.each(function(block, i) {
    block.xScale = d3.scale.linear().domain(block.domain).range([1, block.width]).clamp(true);
    xAxis = d3.svg.axis()
              .orient((isEven(i)) ? 'top' : 'bottom')
              .tickValues(block.domain)
              .tickSize(tick_height,0)
              .scale(block.xScale);
    d3.select(this)
      .call(xAxis)
      .attr('transform', 'translate(' + sumPreviousWidths + ',' + axis_height + ')');
    sumPreviousWidths += block.width;

    d3.select(this).select('path.block')
      .attr('d', arrow(block.width, block.dir));

    d3.select(this).selectAll('path.gene')
      .attr('d', gene_path(block));
  });
};

/*
// Create breakend table *************************************************

var rows = d3.select("#breakend-list tbody").selectAll('tr')
  .data(breakends)
  .enter()
  .append('tr')
  .attr('class', function(d) {
    return 'chr' + d['CHROM'] + '-' + d['POS'];
  })
  .on("click", function(d, i) {
    selected_breakend = d;
    //get_genes();
    $('#breakend-list').find('tr.highlight').removeClass('highlight');
    $(this).addClass('highlight');
  });
d3.select("#breakend-list tbody").select('tr').classed('highlight', true);

var cells = rows.selectAll("td")
  .data(function(row) {
    return columns.map(function(column) {
      var cell = row[column];
      if (typeof cell == 'object') {
        return Object.keys(cell);
      }
      return cell;
    })
  })
  .enter()
  .append("td")
  .text(function(d) {
    return d;
  });
*/
// Create list of genes around a selected breakend ***********************

/* TODO
1. use strict ranges (use block regions as cutoffs)
2. show indicators of function (cancer-related particularly)
*/
var gene_attrs_to_show = ['external_name', 'start', 'end', 'biotype'];
var gene_headers = ['Name', 'Start', 'End', 'Biotype'];
var gene_headers_filter = [undefined, undefined, undefined, 'select'];
var gene_list = d3.select("#gene-list");
var genes_top, genes_bottom, combined_list, start, end, breakpoint_index;
var table_width = Math.round(12/num_breakpoints);

// Create breakpoint objects
var breakpoints = [];
for (var i =0; i < num_breakpoints; i++) {
  breakpoint = {}
  breakpoint.start_block =  blocks[i].end;
  breakpoint.end_block = blocks[i + 1].start;

  breakpoint.start = breakpoint.start_block.chrom + ':' + breakpoint.start_block.pos;
  breakpoint.end = breakpoint.end_block.chrom + ':' + breakpoint.end_block.pos;
  breakpoint.external_name = 'Breakpoint';
  breakpoint.name =  breakpoint.start + ' | ' + breakpoint.end;

  genes_top = genes[i];
  genes_bottom = genes[i+1];
  genes_top = (genes_top) ? genes_top : [];
  genes_bottom = (genes_bottom) ? genes_bottom : [];

  breakpoint.index = genes_top.length;
  breakpoint.combined_list = genes_top.concat(breakpoint).concat(genes_bottom);

  breakpoints[i] = breakpoint;
}
var w, row, table;
// Make one gene table per breakpoint
gene_list.selectAll('div.breakpoint')
  .data(breakpoints).enter()
  .append('div')
  .classed('breakpoint', true)
  .classed('container', true)
  .classed('col-xs-' + table_width, true)  
  .attr('max-height', 230);

gene_list.selectAll('div.breakpoint').each(function(breakpoint, i) {
  // Add header
  d3.select(this).append('div')
    .classed('panel-heading', true)
    .text(breakpoint.name);

  // Add table
  d3.select(this)
    .append('div')
      .classed('container-fluid', true)
    .append('table')
      .classed('table-no-bordered', true)
      .classed('gene-table', true)
      .classed('gene-table-' + i, true)
      .attr('data-toggle', 'table')
      .attr('data-height', 230)
      .attr('data-id-field', 'external_name')
    .append('thead').append('tr').selectAll('th')
      .data(gene_attrs_to_show).enter()
    .append('th') // Add column headings
      .attr('data-field', function (gene_attr) { return gene_attr; })
      .text(function (gene_attr, j) { return gene_headers[j]; });

  // Populate table with gene list
  d3.select(this).select('table').append('tbody');
  table = $('.gene-table-' + i);
  table.bootstrapTable({data: breakpoint.combined_list});
  table.bootstrapTable('resetWidth');

  // Color text to match breakend visualization
  d3.select(this).selectAll('table tbody tr')
    .style('color', function(gene, j) {
      return blocks[i + (j > breakpoint.index)].color;
    });

  // Style breakpoint in list
  d3.select(this).select('table tbody tr[data-index="' + breakpoint.index + '"]')
    .classed('breakpoint', true)
    .style('background', 'black')
    .style('color','white');

  //Scroll to breakpoint
  var offset = $('.gene-table-' + i + ' > tbody > tr[data-index=' + 
    breakpoint.index + ']').offset().top
  var offset_header = $('.gene-table-' + i + ' > tbody > tr[data-index=0]').offset().top;
  $('div.fixed-table-body:has(.gene-table-1)').scrollTop(offset-offset_header);
});

</script>
{% endblock %}