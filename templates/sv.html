{% extends "layout.html" %}
{% block body %}
<div class="container">
	<h3>Sample: {{sample_name}}</h3>
	<h4>SV: {{event_id}}</h4>
	<br>
	<table class="table table-hover" id="breakend-list">
		<thead><tr>
		{% for attr in attrs_to_show %}
			<th>{{ attr }}</th>
		{% endfor %}
		</tr></thead>
		<tbody></tbody>
	</table>

  <h4>Structure View</h4>
  <div id="breakend-viz"></div>
  
  <h4>Genes near break points</h4>
  <div id="gene-list" class="row"></div>

</div>

<script type="text/javascript">
var event_type = {{ event_type|tojson|safe }};
var breakends = {{ breakends|tojson|safe }};
var columns = {{ attrs_to_show|tojson|safe }};
var selected_breakend = breakends[0];
var arrangement = {{ arrangement|tojson|safe }};
var num_breakpoints = arrangement.length;
var blocks = {{ blocks|tojson|safe }};
var genes = {{ genes|tojson|safe }};

// SV Visualization ******************************************************

// SVG setup 

var svg_width = 1000;
var svg_height = 120;
var viz = d3.select("#breakend-viz").append("svg")
  .attr('height', svg_height);

// Create sequence blocks

var block_scale = 50;
var block_height = 50;
var block_padding = 0;
var block_default_w = 10000;
var block_color = ['rgba(0,0,0,0.8)', 'rgba(0,0,150,0.5)', 'rgba(0,0,0,0.8)'];
var block_group, rects, arrows, bp_labels, start_label, x0, a;

var arrow = function(xLength, yPad, direction) {
  // should use transform instead of adding pad
  if (direction) {
    var lineData = [
      { "x": 0,   "y": yPad},  { "x": xLength-20,  "y": yPad},
      { "x": xLength,  "y": 20+yPad}, { "x": xLength-20,  "y": 40+yPad},
      { "x": 0,  "y": 40+yPad},  { "x": 0, "y": yPad}];
  } else {
    var lineData = [
      { "x": xLength,   "y": yPad},  { "x": 20,  "y": yPad},
      { "x": 0,  "y": 20+yPad}, { "x": 20,  "y": 40+yPad},
      { "x": xLength,  "y": 40+yPad},  { "x": xLength, "y": yPad}];
  }

  var lineFunction = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");

  return lineFunction(lineData);
};

// Load JSON data on blocks
var json_blocks_url = '/sample:{{sample_name}}/event:{{event_id}}/sv_blocks.json';
d3.json(json_blocks_url, function(error, data) {
  if (error) throw error;

  x0 = 0;
  data.forEach(function(d) {
    var w = Math.abs(d.end.pos - d.start.pos);
    var x1 = x0 + w;
    d.x0 = x0;
    d.w = w;
    d.x1 = x1;
    x0 = x1;
    d.expanded = false;
  });

  viz.attr('width', (block_default_w/block_scale + block_padding)*data.length);
  var xScale = d3.scale.linear()
    .domain([0, x0])
    .range([0, svg_width]);

  var y = 50;
  block_group = viz.selectAll('g')
      .data(data)
      .enter()
      .append('g');

  block_group
      .attr('id', function(d) {
        d.id = 'chr' + d.start.chrom + '' + d.start.pos;
        return d.id;
      })
      .attr('transform', function(d, i) {
        d.x_offset = i*(block_default_w/block_scale + block_padding);
        return 'translate(' + d.x_offset + ', ' + 0 + ')';
      })
      .classed('lined', function(d, i) {
        return (i != 0); // :^C
      });
  
  arrows = block_group.append('path')
      .classed('sequence_block',true)
      .attr('d', function (d) {
        d.xLength = block_default_w/block_scale;
        return arrow(d.xLength, 60, d.dir);
      })
      .attr('fill', function(d, i) {
        return block_color[i];
      })
      .on('click', function(d, i) {
        d.expanded = !d.expanded;
        expandBlock(d, i);
      });

  bp_labels = viz.selectAll('g.lined')
    .append('g')
    .data(function(d, i){
      return arrangement; // doesn't work as just data(arrangement)...
    });

  bp_labels
    .on('mouseover', function() {
      d3.select(this).classed("select-label", true);
      d3.select(this).select('text.start-label').attr('x', function() {
        return -(this.textLength.baseVal.valueInSpecifiedUnits + label_padding);
      });

      // need to include unique IDs for breakends in dataset for this object instead
      this.__data__.forEach(function(d) {
        var selected_end = 'chr' + d[0] + '-' + d[1];
        d3.select('.' + selected_end).classed('bolded', true);
      });

    })
    .on('mouseout', function() {
      d3.select(this).classed("select-label", false);
      d3.select(this).select('text.start-label').attr('x', function() {
        return -(this.textLength.baseVal.valueInSpecifiedUnits + label_padding);
      });

      this.__data__.forEach(function(d) {
        var selected_end = 'chr' + d[0] + '-' + d[1];
        d3.select('.' + selected_end).classed('bolded', false);
      });
    });

  bp_labels
    .append('line')
      .attr('x1', 0)
      .attr('x2', 0)
      .attr('y1', 0)
      .attr('y2', 100)
      .attr('stroke', 'black')
      .attr('stroke-width', 2);

  var label_padding = 5;
  var label_height = 20;
  start_label = bp_labels
    .append('text')
    .text(function(d, i) {
      return d[0][0] + ': ' + d[0][1];
    });

  start_label
    .attr('class', function(d) {
      return 'chr' + d[0][0] + '-' + d[0][1];
    })
    .classed('start-label', true)
    .attr('x', function() {
      return -(this.textLength.baseVal.valueInSpecifiedUnits + label_padding);
    })
    .attr('y', label_height);

  var end_label = bp_labels
    .append('text')
    .text(function(d) {
      return d[1][0] + ': ' + d[1][1];
    })
    .attr('class', function(d) {
      return 'chr' + d[1][0] + '-' + d[1][1];
    })
    .attr('x', label_padding)
    .attr('y', label_height);

  // Show scroll bar?
  var expandBlock = function(s_d, s_i) {
      var selected_group = d3.select('#' + s_d.id);
      var selected_arrow = selected_group.select('path');

      var old_width = s_d.xLength;
      var new_width = d3.round(((s_d.expanded) ? s_d.w : block_default_w)/block_scale);
      var width_change = new_width - old_width;

      data[s_i].xLength = new_width;
      selected_arrow.attr('d', arrow(new_width, 60, s_d.dir));

      for (i = s_i + 1; i < data.length; i++) { 
        var next = d3.select('#' + data[i].id); 
        data[i].x_offset = data[i].x_offset + width_change;
        next.attr('transform',  'translate(' + data[i].x_offset + ', ' + 0 + ')');
      }
  };
});


// Create breakend table *************************************************

var rows = d3.select("#breakend-list tbody").selectAll('tr')
  .data(breakends)
  .enter()
  .append('tr')
  .attr('class', function(d) {
    return 'chr' + d['CHROM'] + '-' + d['POS'];
  })
  .on("click", function(d, i) {
    selected_breakend = d;
    //get_genes();
    $('#breakend-list').find('tr.highlight').removeClass('highlight');
    $(this).addClass('highlight');
  });
d3.select("#breakend-list tbody").select('tr').classed('highlight', true);

var cells = rows.selectAll("td")
  .data(function(row) {
    return columns.map(function(column) {
      var cell = row[column];
      if (typeof cell == 'object') {
        return Object.keys(cell);
      }
      return cell;
    })
  })
  .enter()
  .append("td")
  .text(function(d) {
    return d;
  });

// Create list of genes around a selected breakend ***********************

/* TODO
1. use strict ranges (use block regions as cutoffs)
2. show indicators of function (cancer-related particularly)
*/

var gene_attrs_to_show = ['external_name', 'start', 'end', 'biotype'];
var gene_headers = ['Name', 'Start', 'End', 'Biotype'];
var gene_list = d3.select("#gene-list");
var genes_top, genes_bottom, combined_list, start, end, breakpoint_index;
var table_width = Math.round(12/num_breakpoints);

// Make one gene table per breakpoint
for (var bp_i =0; bp_i < num_breakpoints; bp_i++) {
  var gene_div = gene_list.append('div')
    .classed('col-xs-' + table_width, true)
    .classed('container', true)

  start = blocks[bp_i].end;
  end = blocks[bp_i + 1].start;
  var bp_name = start.chrom + ':' + start.pos + ' | ' + end.chrom + ':' + end.pos;
  gene_div.append('div')
    .classed('panel-heading', true)
    .text(bp_name);

  var gene_table = gene_div.append('div')
      .classed('container-fluid', true)
    .append('table')
      .classed('table-no-bordered', true)
      .attr('data-toggle', 'table')
      .attr('data-cache', false)
      .attr('data-height', '225')
      .attr('id', 'gene-table-' + bp_i);

  gene_table.append('thead').append('tr').selectAll('th')
      .data(gene_attrs_to_show).enter()
      .append('th')
      .attr('data-field', function (d) { return d; })
      .text(function (d, i) { return gene_headers[i]; });

  gene_table.append('tbody');

  genes_top = genes[bp_i];
  genes_bottom = genes[bp_i+1];
  breakpoint_index = genes[bp_i].length;

  combined_list = genes_top.concat(genes_bottom);

  var table = $('#gene-table-' + bp_i);
  table.bootstrapTable({data: combined_list});
  table.bootstrapTable('resetWidth');

  d3.select('#gene-table-' + bp_i)
    .selectAll('tr[data-index="' + breakpoint_index + '"]')
    .attr('style', 'border-top: solid black;')
  d3.select('#gene-table-' + bp_i).selectAll('tbody tr')
    .attr('style', function(d, i) {
      var new_style = 'color: ' + block_color[bp_i + (i >= breakpoint_index)] + ';';
      var old_style = d3.select(this).attr('style');
      return ((old_style) ? old_style : '')  + new_style
    });
}




/*
var gene_list_title = gene_list.select("h4");
var gene_list_headings = gene_list.select('thead tr');
// Initialize table


// Update table

var get_genes = function() {
  // Create url
  var chrom_id = selected_breakend['CHROM'];
  var position = selected_breakend['POS'];
  var start = position - gene_range;
  var end = position + gene_range;
  var url = '/genes/' + chrom_id + ':' + start + '-' + end;

  // Update table if url has changed
  if (url != last_url) {
    $.getJSON(url, function(json){
      // Create table title
      var heading_msg = "Genes within " + gene_range + "bp of selected breakend " + selected_breakend['CHROM'] + ':' + selected_breakend['POS'];
      gene_list_title.text(heading_msg);

      if (json) {
        // Format biotype column
        for(var i=0; i<json.length; i++) { // inefficient (need to figure out how bootstrap-table formatter works)
          json[i]['biotype'] = json[i]['biotype'].replace('_', ' ');
        }

        // Load json into bootstrap-table via url
        $('#gene-table').bootstrapTable('load', json);
        $('#table').bootstrapTable('resetWidth');

        // D3-ify (bind data to html elements)
        rows = gene_list.select('tbody').selectAll('tr')
        rows.data(json).enter();

        cols = rows.selectAll('td');
        cols.data(function(d) {
          return _.values(_.pick(d, gene_attrs_to_show));
        }).enter();
        cols.attr('class', function(d, i) {
          return gene_attrs_to_show[i];
        })

        // Add links to name column
        d3.selectAll('.external_name')
          .text('')
          .append('a')
          .attr('href', function(d, i) {
            return 'http://www.genecards.org/cgi-bin/carddisp.pl?gene=' + d3.select(this.parentNode.parentNode).datum().id;
          })
          .text(function (d) { return d; });
      } 
    });
    last_url = url;
  }
};
get_genes();
*/    
</script>
{% endblock %}